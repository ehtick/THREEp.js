<!DOCTYPE html>
<!--   *** example ***
/**
 * @author hofk / http://threejs.hofk.de/
*/
-->
<html lang="de">
<head>
	<title> example </title>
	<meta charset="utf-8" />
</head>
<body>

</body>

<script src="three.min.87.js"></script>
<script src="OrbitControls.js"></script>
<script src="THREEx.WindowResize.js"></script>
<script src="THREEp.js"></script>

<script>

'use strict'
	
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200000 );
camera.position.set( 40, 0, 80 );
var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0xeeeeee, 1 );	
var container = document.createElement( 'div' );
document.body.appendChild( container );
container.appendChild( renderer.domElement ); 
THREEx.WindowResize( renderer, camera );
var controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.enableZoom = true;
var clock  = new THREE.Clock( true );	
var time;	// for animate .morphVertices( time ) and .morphFaces( time ) )

var floorGeometrie = new THREE.PlaneGeometry( 64, 64, 1, 1 );
var floorTexture = new THREE.TextureLoader().load( "checkerboard.png" );
floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
floorTexture.repeat.set( 5, 5 );
var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, transparent: true, opacity: 0.2 } );
var floor = new THREE.Mesh(floorGeometrie, floorMaterial);  
floor.rotation.x = -1.57;

scene.add( floor );

// material
var uvTex			= new THREE.TextureLoader().load( "uvgrid01.png" );
var waterlilyTex	= new THREE.TextureLoader().load( "waterlily.png" );
//var note2Tex	= new THREE.TextureLoader().load( "note2.jpg" );
var dahliaTex 	= new THREE.TextureLoader().load( "dahlia.png" );

var side =  THREE.DoubleSide;

var materials = [
																						// material index:
    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0.15, 	side: side	} ),	//  0 transparent
	new THREE.MeshBasicMaterial( { map: uvTex, 							side: side	} ),	//  1 uv grid
	new THREE.MeshPhongMaterial( { color: 0xff0000, emissive: 0xff0000, side: side,  } ),	//  2 red
	new THREE.MeshPhongMaterial( { color: 0x00ff00, emissive: 0x00ff00, side: side, } ),	//  3 green
	new THREE.MeshPhongMaterial( { color: 0x0000ff, emissive: 0x0000ff, side: side, } ),	//  4 blue
	new THREE.MeshPhongMaterial( { color: 0xffff00, emissive: 0xffff00, side: side, } ),	//  5 yellow
	new THREE.MeshPhongMaterial( { color: 0xff00ff, emissive: 0xff00ff, side: side, } ),	//  6 mgenta
	new THREE.MeshPhongMaterial( { color: 0x00ffff, emissive: 0x00ffff, side: side, } ),	//  7 cyan	
	new THREE.MeshBasicMaterial( { map: dahliaTex,						side: side	} ),	//  8 photo dahlia (free)
	new THREE.MeshPhongMaterial( { color: 0xee55ff, emissive: 0x7733dd, side: side	} ),	//  9 color
	new THREE.MeshPhongMaterial( { color: 0x444444, emissive: 0x333333, side: side	} )		// 10 grey
	
];

var material = new THREE.MeshBasicMaterial( { map: dahliaTex, side: side, wireframe: false } );
 // var material = new THREE.MeshPhongMaterial( { side: side, wireframe: true } );

	
// geometry


var parameters = {

	materialSouth: function ( u, v, t ) { return 0.5 * ( 1 + Math.sin( u + t) ) },
	materialNorth: function ( u, v, t ) { return v },
	materialPlane: function ( u, t ) { return u },
	materialPlane: function ( v, t ) { return v },
	
	equator: 10,
	wedges: 20,
	usedWedges: 18,
	wedgeOpen: false, // default is true now
	
	topCircle: 18,
	withTop: true,
	
	bottomCircle: 2,
	withBottom: true,
		
		
	squeeze: function( u, t ) { return 0.3 + 0.25 * ( 1 + Math.sin( u + 5*t) ) }, 
	//squeeze: function( u, t ) { return 0.99},  // if 1 ERROR 1/0 - INFINITY // to do
	//squeeze: function( u, t ) { return 0.5 },
	//squeeze: function ( u, t ) { return 0.45 * ( 1 + Math.sin( 6.28 * u ) * Math.sin( t )  ) },
	//rPhiTheta: function ( u, v, t ) { return 0.75 + 2 * (0.5-v)*(0.5-v) + 0.2 * Math.sin( 6.28 * u) },
	//stretchNorth: function ( u, v, t ) { return 1 + 0.4 * u },
	//moveX: function ( u, v, t ) { return 1 + v },
	
}

var geometry = new THREE.BufferGeometry();
geometry.createMorphGeometry = THREEp.createMorphGeometry; // insert the methode from THREEp.js
geometry.createMorphGeometry( parameters ); // apply the methode

// mesh
//var mesh = new THREE.Mesh( geometry, material );
var mesh = new THREE.Mesh( geometry, materials );
scene.add( mesh );


animate();

//..................

function animate() {

	requestAnimationFrame( animate );
	
	time = clock.getElapsedTime();
	
	geometry.morphVertices( time );		
 	geometry.morphFaces( time );

	renderer.render( scene, camera );
	controls.update();
	
}
</script>

</html>