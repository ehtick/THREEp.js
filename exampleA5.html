<!DOCTYPE html>
<!--   *** example ***
/**
 * @author hofk / http://threejs.hofk.de/
*/
-->
<html lang="de">
<head>
	<title> example </title>
	<meta charset="utf-8" />
</head>
<body>

	<!-- D E B U G !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -->
		<input type="text" size="500" id="debug" value="Debug: " > <br /> 
	<!-- D E B U G !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! -->
	
</body>


<script src="three.min.87.js"></script>
<script src="OrbitControls.js"></script>
<script src="THREEx.WindowResize.js"></script>
<script src="THREEp.js"></script>

<script>

'use strict'
	
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 200000 );
camera.position.set( 40, 0, 80 );
var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.setClearColor( 0xeeeeee, 1 );	
var container = document.createElement( 'div' );
document.body.appendChild( container );
container.appendChild( renderer.domElement ); 
THREEx.WindowResize( renderer, camera );
var controls = new THREE.OrbitControls( camera, renderer.domElement );
controls.enableZoom = true;
var clock  = new THREE.Clock( true );	
var time;	// for animate .morphVertices( time ) and .morphFaces( time ) )

var floorGeometrie = new THREE.PlaneGeometry( 64, 64, 1, 1 );
var floorTexture = new THREE.TextureLoader().load( "checkerboard.png" );
floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
floorTexture.repeat.set( 5, 5 );
var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, transparent: true, opacity: 0.2 } );
var floor = new THREE.Mesh(floorGeometrie, floorMaterial);  
floor.rotation.x = -1.57;

// scene.add( floor ); // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// material
var uvTex			= new THREE.TextureLoader().load( "uvgrid01.png" );
var waterlilyTex	= new THREE.TextureLoader().load( "waterlily.png" );
//var note2Tex	= new THREE.TextureLoader().load( "note2.jpg" );
var dahliaTex 	= new THREE.TextureLoader().load( "dahlia.png" );

var side =  THREE.DoubleSide;

var materials = [
																						// material index:
    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0.15, 	side: side } ),	//  0 transparent
	new THREE.MeshBasicMaterial( { map: uvTex,							side: side } ),	//  1 uv grid
	new THREE.MeshPhongMaterial( { color: 0xff0000, emissive: 0xff0000, side: side } ),	//  2 red
	new THREE.MeshPhongMaterial( { color: 0x00ff00, emissive: 0x00ff00, side: side } ),	//  3 green
	new THREE.MeshPhongMaterial( { color: 0x0000ff, emissive: 0x0000ff, side: side } ),	//  4 blue
	new THREE.MeshPhongMaterial( { color: 0xffff00, emissive: 0xffff00, side: side } ),	//  5 yellow
	new THREE.MeshPhongMaterial( { color: 0xff00ff, emissive: 0xff00ff, side: side,	wireframe: true } ),	//  6 mgenta
	new THREE.MeshPhongMaterial( { color: 0x00ffff, emissive: 0x00ffff, side: side } ),	//  7 cyan	
	new THREE.MeshBasicMaterial( { map: dahliaTex,						side: side } ),	//  8 photo dahlia (free)
	new THREE.MeshPhongMaterial( { color: 0xee55ff, emissive: 0x7733dd, side: side } ),	//  9 color
	new THREE.MeshPhongMaterial( { color: 0x444444, emissive: 0x333333, side: side } )		// 10 grey
	
];

var material = new THREE.MeshBasicMaterial( { map: dahliaTex, side: side, wireframe: true } );
 // var material = new THREE.MeshPhongMaterial( { side: side, wireframe: true } );

	
// geometry


var parameters = {

	wedgeOpen: true,

	equator: 30,
	
	//equatorGap: function ( u, t ) { return 0.1},
	
	wedges: 4,
	usedWedges: 4,
	
	top: 52,
	withTop: true,
	
	bottom: 30,
	//withBottom: true,
	
	//moveX: function ( u, v, t ) { return Math.sin( v + 0.5*t) },
	//moveY: function ( u, v, t ) { return Math.sin( 1.57 * v + t) },

	
	materialSouth: function ( u, v, t ) { return 0.8},
	materialNorth: function ( u, v, t ) { return 0.8},
	materialPlane: function ( u, v, t ) { return 0.6 },
	materialWedge: function ( u, v, t ) { return 0.1},
	
	//startAzimuth: function( v, t ) { return 0.2 + 0.1 * ( 1 + Math.sin( v + 5 * t) ) }, 
	//endAzimuth: function( v, t ) { return 0.9 + 0.1 * ( 1 + Math.cos( v + 5 * t) ) }, 
	//scaleAzimuth: function( u, t ) { return  Math.sqrt( u ) }, 
	
	startPole: function( u, t ) { return 0.2 * ( 1 + Math.sin( 25.12 * u + t ) ) }, 
	//endPole: function( u, t ) { return 0.6 + 0.4 * ( 1 + Math.sin( 25.12 * u ) ) }, 
	
	//startPole: function( u, t ) { return 0.2 }, 
	//endPole: function( u, t ) { return 0.8 },
	
	
	// !!!!!!!!!!!!!!!!!!!!!! scalePole !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//scalePole: function( v, t ) { return v * v},
	//scalePole: function( v, t ) { return  Math.sqrt( v )  },
	
	scalePoleH: function( v, t ) { return  v * v },
	//scalePoleH: function( v, t ) { return  Math.sqrt( v ) },
	
	//scalePole: function( v, t ) { return  v }, // als Test  S N    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//scalePoleH: function( v, t ) { return  v  },  // als Test  S N    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	//scalePole: function( v, t ) { return 0.5 *( 1 - Math.cos( 3.14 * v ) ) },
	//scalePole: function( v, t ) { return Math.sin( 1.57 * v )*( 1 + 0.2*Math.sin(t) )*0.8  },
		
	
	
	//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	
	//stretchSouth: function ( u, v, t ) { return  4 },
	//stretchNorth: function ( u, v, t ) { return  4 },	
	
	//squeeze: function( u, t ) { return 0.3 + 0.25 * ( 1 + Math.sin( u + 5*t) ) }, 
	//squeeze: function( u, t ) { return 0.99},  // if 1 ERROR 1/0 - INFINITY // to do
	//squeeze: function( u, t ) { return 0.5 },
	
	//rAzimuthPole: function ( u, v, t ) { return 0.5 + ( v - 0.5 ) * ( v - 0.5 ) },
	
	

}

var geometry = new THREE.BufferGeometry();
geometry.createMorphGeometry = THREEp.createMorphGeometry; // insert the methode from THREEp.js
geometry.createMorphGeometry( parameters ); // apply the methode

// mesh
//var mesh = new THREE.Mesh( geometry, material );
var mesh = new THREE.Mesh( geometry, materials );
scene.add( mesh );


animate();

//..................

function animate() {

	requestAnimationFrame( animate );
	
	time = clock.getElapsedTime();
	
	//   evtl. wegen DEBUG rausnehmen !!!!!!!!!!!!!!!!!!!!!!!!
	geometry.morphVertices( time );		
 	geometry.morphFaces( time );
	////////////////////////////////////////////////////////////
	
	renderer.render( scene, camera );
	controls.update();
	
}
</script>

</html>